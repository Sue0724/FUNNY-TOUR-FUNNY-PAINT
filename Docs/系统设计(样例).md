<!-- TOC -->

- [1. 系统结构](#1-系统结构)
    - [1.1. 前端系统结构](#11-前端系统结构)
      - [1.1.1. 地图画布界面模块](#111-地图画布界面模块)
    - [1.2. 后端系统结构](#12-后端系统结构)
    - [1.3. 系统结构图：](#13-系统结构图)
    - [1.4. 系统类图](#14-系统类图)
    - [1.5. 关键数据结构定义](#15-关键数据结构定义)
        - [1.5.1. 前端数据结构](#151-前端数据结构)
        - [1.5.2. 地点数据结构设计](#152-地点数据结构设计)
        - [1.5.3. 绘画路径数据结构设计](#153-绘画路径数据结构设计)
        - [1.5.4. 邀请码数据项结构设计](#154-邀请码数据项结构设计)
        - [1.5.5. 课程-学生关系表结构设计](#155-课程-学生关系表结构设计)
        - [1.5.6. 课程讨论结构设计](#156-课程讨论结构设计)
        - [1.5.7. 数据关联结构设计](#157-数据关联结构设计)
    - [1.6. 关键算法设计](#16-关键算法设计)
        - [1.6.1. 画布绑定地图](#161-数据库的api接口算法设计)
        - [1.6.2. 后端的API接口算法设计](#162-后端的api接口算法设计)
    - [1.7. 数据管理说明](#17-数据管理说明)
        - [1.7.1. 使用数据库概述](#171-使用数据库概述)

<!-- /TOC -->

<a id="markdown-1-系统结构" name="1-系统结构"></a>
# 1. 系统结构
<a id="markdown-11-前端系统结构" name="11-前端系统结构"></a>
## 1.1. 前端系统结构
==以下这些都需要改，补充前端其他界面信息==

前端系统分为9个模块：
1. 地图画布界面模块。主要功能：编辑行程地点，在地图上进行绘画记录。
2. 注册账号模块。注册功能分为六个步骤，填入用户名、填入密码、填入确认密码、点击注册按钮、传递用户信息的后端管理判断、后台返回响应。
3. 账号登入模块。主要的登录功能分为五个步骤，填入用户名、填入密码点击注册按钮、传递用户信息的后端管理判断、后台返回响应。
4. 修改密码模块。
5. 选课主界面模块。主要功能：提供给学生选课退课、提供给所有用户利用课程名字或者课程分类来检索课程。提供给所有用户跳转到其他页面的按钮。
6. 个人信息界面模块 。主要功能：提示用户当前的身份（学生、老师、管理员）、基本的个人信息，以及已经选择的课程和选择课程的成功率是多大，提供给所有用户跳转到其他页面的按钮。
7. 个人信息修改界面模块。主要功能：提供用户修改个人基本信息，能够修改用户的身份。提供给所有用户跳转到其他页面的按钮。
8. 课程讨论界面模块。主要功能：可以给学生、老师进行发言，发言会公布到页面中去。
9. 课程评价界面模块。
10. 老师上传课程界面模块。主要功能：老师填写课程的信息，课程能够上传到选课主页面中。
    
==以上这些都需要改，补充前端其他界面信息==
<a id="markdown-111-地图画布界面模块" name="111-地图画布界面模块"></a>
### 1.1.1 地图画布界面模块
地图画布界面模块共分为4个模块：
1. 地图画布主界面模块。主要功能：展示已加入当前行程的地点标记，展示当前行程的绘画，提供能导航至相应功能界面（选择地点、绘画、日程）的导航工具栏。
2. 选择地点界面模块。主要功能：选择行程中心地点，根据关键词搜索推荐周边地点，通过点击地图或精确搜索自定义添加地点，将地点添加至当前行程，收藏地点，了解地点详情，以列表形式分类显示地点。
3. 绘画界面模块。主要功能：显示已加入当前行程的地点标记，在地图上绘画（拖动或缩放地图时，绘画会跟随地图移动），切换画笔颜色、粗细，使用橡皮擦擦除绘画。
4. 日程界面模块。主要功能：显示已加入当前行程的地点标记，对任意两个行程地点进行路线规划（支持多交通工具：驾车、步行、自行车、电动车，可显示规划路线、距离、时间），设定行程地点所属日程，设定行程地点在所属日程中的游览顺序，删除行程地点。
<a id="markdown-12-后端系统结构" name="12-后端系统结构"></a>
## 1.2. 后端系统结构
后端系统的功能模块分为用户账号模块，主页课程模块，课程模块，讨论模块。个人中心模块。
1. 其中用户账号模块包括用户账号注册，用户账号登陆子模块。
    1. 用户账号注册模块实现用户注册页面的展示，用户创建账号的数据提交与收取，数据检验和数据入库，以及前端反馈等功能。
    对应的接口为register函数，通过'/register'访问，可接受前端传入的post数据，进行数据结构检错后调用数据库进行用户数据库的更新，并向前端传递对应的响应信息。
    2. 用户账号登陆子模块实现用户登录页面的展示，用户登录的数据提交与收取，数据检验和数据入库，以及前端反馈等功能。
    对应的接口为login函数，通过'/login'访问，可接受前端传入的post数据，进行数据结构检错后调用数据库进行数据的查找，并向前端传递对应的响应信息。
2. 主页课程模块包括选课，退课模块，课程显示模块，登录注销模块，live2d模块等子模块。
	1. 选课，退课模块实现了特定用户对某一个课程的选课，退课的功能。
	对应的接口为message1，通过用户前 吧端传过来的操作，完成对应选课退选操作后，将对应数据更新到数据库中。并向前端传递操作消息。
	2. 课程显示模块实现了从数据库中加载所有的课程信息并显示，并且可以根据对应的分类符分类显示课程的功能。还能根据数据库进行实时的课程页面更新（需要刷新页面）。还提供了跳转课程更多信息页面的跳转链接。
	对应的接口为index，能够展示当前所有的课程以及其信息，并且能够根据对应的按钮实现对应的功能。
	3. 登陆注销模块实现了课程主页的快速登陆和注销的功能。
	对应的接口为message2:实现用户注销功能。
	4. live2d模块实现了网站的live2d美化功能。
	此部分由网页js部分实现。
3. 课程模块包括课程简介模块，课程上传模块，课程评价模块等子模块。
	1. 课程简介模块实现了根据对应课程显示对应课程的对应信息功能。
	对应接口为class_info2()：通过前端的post信息生成特定的url以供class_info函数使用。
和class_info(id): 根据传入的特定课程的url返回对应渲染页面。
	1. 课程上传模块实现了老师用户发布新的课程功能。
	对应的接口为classinfo()：从前端获取信息，将其送入数据库中，实现老师发布新课程功能。
	2. 课程评价实现了可查看特定课程的评价区，并只有选择过该课程的学生才能进行评价，评价按时间先后排序。
	对应接口为message_x()和class_comments(course_id)，分别完成特定的课程url生成，和特定课程评价区的实现。
1. 讨论模块包括讨论区模块子模块。
	1. 讨论区实现了能够在其中自有讨论的功能，顺序按时间排序。
	对应接口为class_discussion()，从数据库中读取当前所有讨论的信息，并能够从前端向数据库进行信息的更新，实现自由讨论区的功能。
2. 个人中心模块包括学生个人中心模块，老师个人中心模块等子模块。
	1. 学生个人中心模块实现了可按照特定学生的情况显示其对应的选课状况。
	2. 老师个人中心模块实现了可安特定老师的情况显示其对应的发布的课程情况。
	对应接口均为user()和setting()，实现个人中心的页面，能够针对不同身份的人进行不同身份的显示。以及对应个人信息的更新。

<a id="markdown-13-系统结构图" name="13-系统结构图"></a>
## 1.3. 系统结构图：
![](images/系统结构.png)

<a id="markdown-14-系统类图" name="14-系统类图"></a>
## 1.4. 系统类图
![](images/类图.png)

<a id="markdown-15-关键数据结构定义" name="15-关键数据结构定义"></a>
## 1.5. 关键数据结构定义
<a id="markdown-151-前端数据结构" name="151-前端数据结构"></a>
### 1.5.1. 前端数据结构
1. 地图相关界面主要数据：tripMarkers列表存储日程地点信息，allMarkers列表存储所有地点信息，selfAddedMarkers列表存储自定义添加的地点信息，recommendMarkers列表存储周边搜索推荐的地点信息，collectMarkers列表存储收藏的地点信息，fixedLatitude存储行程中心的纬度，fixedLongitude存储行程中心的经度，markerId存储已存在地点的最大id值，以上数据传递给后端进行存取，其中列表以JSON字符串形式存储。

2. 画布相关界面主要数据：paths列表存储绘画路径，以JSON字符串形式存储，传递给后端进行存取。

==以下这些都需要改，补充前端其他界面信息==
3. 个人信息界面主要数据：userinf是一个字典，字典用来存储个人信息，字典具体格式如下：

    ```js
    userinf:{
        name : " ",   //name表示用户的昵称
        ID   : " ",   //ID用来表示用户的身份（游客、教师、学生），
        email: " ",   //email表示用户的电子邮箱
        major: " ",   //major用来表示用户的班级
    }
    ```
    classname是一个具体的字典数组，数组中元素是用来存储用户已经选择的每门课的名字以及选课成功率，数组元素具体格式如下：
    ```js
    classname:{
        name       : " ",   //name表示用户选择的课程的名字
        chenggonglv: " "    //chenggonglv表示该课程选课的成功率。
    }
    ```
4. 个人中心主要数据：inf是一个具体的字典，字典是用来存储用户的基本信息的，字典具体格式如下：
    ```js
    inf:{
        nickname   : " ",   //Nickname用来表示用户的昵称
        name       : " ",   //name用来表示用户的真实姓名
        major      : " ",   //major用来表示用户的班级
        ID         : "",    //ID用来表示用户的学号
        phonenumber: "",    //phonenumber用来表示用户的电话号码
        email      : 0,     //email用来表示用户的邮箱
        invisit    : " "    //invisit用来储存教师邀请码
    }
    ```
5. 课程讨论界面主要数据：message是一个具体的字典数组，数组中元素是用来存储用户讨论的基本信息的，数组元素具体格式如下：
    ```js
    message:{
        name: " ",   //Name用来表示用户的昵称
        msg : " ",   //msg用来表示用户的讨论内容。
    }
    ```
6. 课程简介界面主要数据：inf是一个具体的字典，字典是用来存储课程的基本信息的，字典具体格式如下: 
    ```js
    inf:{
        classname   : " ",   //classame用来表示课程名字
        credit      : " ",   //credit用来表示课程学分
        weeks       : " ",   //weeks用来表示课程具体时间
        teacher     : " ",   //teacher用来表示课程老师
        classroom   : " ",   //classroom用来表示课程上课地点
        introduction: " ",   //introduction用来表示课程介绍
        college     : " "    //college用来表示课程学院
    }
    ``` 
7. 教师上传课程界面主要数据：inf是一个具体的字典，字典是用来存储课程的基本信息的，字典具体格式如下：
    ```js
    inf:{
        classname   : " ",   //classame用来表示课程名字
        credit      : " ",   //credit用来表示课程学分
        weeks       : " ",   //weeks用来表示课程具体时间
        teacher     : " ",   //teacher用来表示课程老师
        classroom   : " ",   //classroom用来表示课程上课地点
        introduction: " ",   //introduction用来表示课程介绍
        college     : " "    //college用来表示课程学院
    }
    ```
==以上这些都需要改，补充前端其他界面信息==

<a id="markdown-152-地点数据结构设计" name="152-地点数据结构设计"></a>
### 1.5.2. 地点数据结构设计
markers列表中一个marker地点元素的数据结构如下：

```js
    marker:{
        id          : int,        //表示地点标记的唯一标识
        name        : string,     //表示地点名称
        category    : string,     //表示地点所属类别
        latitude    : double,     //表示地点的地理纬度
        longitude   : double,     //表示地点的地理经度
        distance    : double,     //表示地点距离行程中心地点的直线距离
        iconPath    : string,     //表示地点标记显示图标的图片路径
        width       : double,     //表示地点标记显示图标的宽度
        height      : double,     //表示地点标记显示图标的高度
        callout     : json_object,//表示地点标记显示的其他属性
        day         : int,        //表示行程地点所属的日程
        daySeq      : int,        //表示行程地点在所属日程中的游览顺序
    }
```

数据成员的具体解释如下：
1. id: int类型，表示地点标记的唯一标识
2. name: string类型，表示地点名称
3. category: string类型，表示地点所属类别
4. latitude: double类型，表示地点的地理纬度
5. longitude: double类型，表示地点的地理经度
6. distance: double类型，表示地点距离行程中心地点的直线距离
7. iconPath: string类型，表示地点标记显示图标的图片路径
8. width: double类型，表示地点标记显示图标的宽度
9. height: double类型，表示地点标记显示图标的高度
10. callout: json_object类型，表示地点标记显示的其他属性
11. day: int类型，表示行程地点所属的日程
12. daySeq: int类型，表示行程地点在所属日程中的游览顺序

<a id="markdown-153-绘画路径数据结构设计" name="153-绘画路径数据结构设计"></a>
### 1.5.3. 绘画路径数据结构设计
paths列表中一个path元素的数据结构如下：

```js
    path:{
        startLat    : double,     //表示绘画路径起点对应的地理纬度
        startLng    : double,     //表示绘画路径起点对应的地理经度
        endLat      : double,     //表示绘画路径终点对应的地理纬度
        endLng      : double,     //表示绘画路径终点对应的地理经度
        strokeStyle : string,     //表示绘画线条的颜色
        lineWidth   : double,     //表示绘画线条的粗细大小
    }
```

数据成员的具体解释如下：
1. startLat: double类型，表示绘画路径起点对应的地理纬度
2. startLng: double类型，表示绘画路径起点对应的地理经度
3. endLat: double类型，表示绘画路径终点对应的地理纬度
4. endLng: double类型，表示绘画路径终点对应的地理经度
5. strokeStyle: string类型，表示绘画线条的颜色
6. lineWidth: double类型，表示绘画线条的粗细大小

<a id="markdown-154-邀请码数据项结构设计" name="154-邀请码数据项结构设计"></a>
### 1.5.4. 邀请码数据项结构设计
邀请码的结构如下：
```python
#存储邀请码的表项
class Visit(db):
    #存储邀请码的库
    __tablename__ = 'visits'
    id            = Column(Integer,primary_key=True,autoincrement=True)
    Visit_code    = Column(String(50),unique=True)
    #一对一的关系
    Teacherid = Column(Integer,ForeignKey('users.id'))
#   
``` 
邀请码表项包括：
1. Visit_code: 邀请码，以字符串表示
1. Teacherid: 一个邀请码最多只能绑定一个老师，即在未使用时，该列为None，在绑定之后变为对应老师的id，不允许多次绑定；

<a id="markdown-155-课程-学生关系表结构设计" name="155-课程-学生关系表结构设计"></a>
### 1.5.5. 课程-学生关系表结构设计
以下为课程，学生的多对多关系表。
```python
#构建的课程-学生的多关系表
Course_stu = Table('Course_stu',
                   db.metadata, #对于老版本的Table，需要显式调用
                   Column('User.id',Integer,ForeignKey('users.id',ondelete='CASCADE',onupdate='CASCADE')),
                   Column('Course.id',Integer,ForeignKey('courses.id', ondelete='CASCADE',onupdate='CASCADE')) #实现级联删除的作用
                   )
```
详细表述如下：构建一个关系表，关联User与Course,此处User指选择该课的学生，多对多的含义即一个课程里面存在多个学生，同样一个学生也可以对应多个课程。
<a id="markdown-156-课程讨论结构设计" name="156-课程讨论结构设计"></a>
### 1.5.6. 课程讨论结构设计
课程讨论表项的定义如下：
```python
#讨论数据库
class Discussion(db): 
    __tablename__ = 'discussions'
    id            = Column(Integer, primary_key=True, autoincrement=True)
    Content       = Column(String(255)) #讨论内容，限长255
    Courseid      = Column(Integer, ForeignKey('courses.id')) #每个讨论对应一个课程
    Userid        = Column(Integer, ForeignKey('users.id')) #每个讨论对应一个发言人
    Sign_time     = Column(DateTime, default=datetime.datetime.now) #发表时间
    Username      = Column(String(255)) #便于查找，存储用户名
    Coursename    = Column(String(40)) #同上，课程名
```    
具体信息解释如下：
1. Content: 表示该讨论的具体内容，限制长度为255，若超长，则返回报错信息；
1. Courseid: 每条讨论对应唯一的课程标识，可以通过课程id来查找所有的该课程的评论；
1. Userid：同样，每条评论对应一个唯一的发表人；
1. Sign_time: 记录该评论的发表时间；
1. Username： 为了节约查询开销，故记录发表该评论的用户名；
1. Coursename：同上，为了节约开销，记录与之关联的课程名称；

<a id="markdown-157-数据关联结构设计" name="157-数据关联结构设计"></a>
### 1.5.7. 数据关联结构设计
前后端数据关联，分页面介绍如下
1. register.html页面的前后端数据关联
前端传入username和password到用户数据库username和password中。
2. login.html页面的前后端数据关联
前端传入的username和password和用户数据库的数据进行匹配。
3. home.html页面的前后端数据关联 
后端读取出来所有课程的缤纷信息，读出所有课程的Coursename，Credit，Weeklast，Teacherid，Course_location，Stu_num，Maxnum，然后视情况将Teacherid转化为id对应的username或者Nickname，然后对于没有登录的用户，其isSignup=”否”，对于登录的用户，如果其在课程成员里其值为是，否则为否，然后对应的信息按类别存到对应的list中。返回到前端即使用jinjia模板渲染，前端的name对应的这里的Coursename，score对应的Credit，week对应的Weeklast，teacher对应的Teacherid转化的值，classroom对应的Course_loaction，signupnum对应的这里的Stu_num，maxnum对应这里的Maxnum，isSignup对应这里的isSignup，classsort对应这里的type_name（由数据库中的Type转化而来）
4. 个人信息页面的前后端数据关联
用户登录后，使用当前会话的username从数据库中获取一条用户的信息，前端的name对应后端数据库信息中的Nickname并经过一定的转化（将None变成空），前端的ID对应后端的Role表项，后端的Role表项和数据库信息的Role表项的对应关系是{None:”空”, 0:”管理员”, 1:”老师”, 2:”学生”}
前端的email对应着后端的数据库信息的Email项，前端的major对应着后端的Classes项。
根据用户的名字获得其选择的所有课程，组成一个列表。
前端的每一个classname中的name对应着列表中一个项的Coursename，每一个概率对应的列表中的一个课程中的元素按一定规则计算后得到的概率。
5. 个人信息更改页面的前后端数据关联
根据用户登录时的username获得当前用户名对应的数据库中的一个表项。
前端的nickname对应后端数据库表项中的Nickname，name对应的是表项中的Truename，major对应的后端数据库表项中的Classes，ID对应的是后端数据库的Userid，phonenumber对应的是数据库表项中的Phonenumber，email对应的数据库中的Email，invisit对应的是邀请码，传入后端后通过查找逻辑来改变当前用户的身份。
6. 课程讨论界面的前后端数据结构关联
首先获得数据库中所有的讨论项。
讨论区的每一个讨论的name对应的是数据库中一个表项的Username项
每一个讨论的time对应的是数据库中一个表项的Sign_time
每一个讨论的Score是数据库中一个表项的Content
7. 课程简介界面的前后端数据关联
首先根据url中的特定id从数据库中获得特定课程的信息表项。
前端的classname对应的后端信息表项的Coursename，credit对应的后端表项的Credit，前端的weeks对应的后端表项的Weeklast， 前端的teacher对应的是teacher的用户名，classroom对应的是数据库表项中的Course_location，introduction对应的是后端数据库的Course_content，
college对应的是数据库中的type经过对应字典映射后的结果。
8. 教师上传课程界面前后端数据关联
前端的classname对应的后端数据库表项数据库表项中的Coursename，前端的credit对应的是后端Credit，weeks对应的是数据库的Weeklast，前端的teacher对应后端数据中课程的username，classroom对应的是数据库中的Course_location。前端的introduction对应的数据库中的Course_content，前端的college经过type字典映射后对应数据库中的Type
数据关联的示意图如下：
![](images/数据关联结构图.png)

<a id="markdown-16-关键算法设计" name="16-关键算法设计"></a>
## 1.6. 关键算法设计
<a id="markdown-161-画布绑定地图" name="161-画布绑定地图"></a>
### 1.6.1. 画布绑定地图

1. 初始化
   1. 获取当前显示地图中心及左上角的经纬度并计算两者差异
   2. 获取当前显示画布中心及左上角的屏幕坐标并计算两者差异
2. 进入绘画模式
   1. 触摸开始，记录起点的屏幕坐标，屏幕坐标转换为经纬度并记录
   2. 触摸移动，记录移动终点的屏幕坐标，屏幕坐标转换为经纬度并记录
   3. 上一个点与当前点组成一条路径，绘制路径
   4. 保存两点的经纬度，更新绘画路径数组
3. 每次地图显示区域改变（拖动、缩放、旋转）
   1. 改变开始，清空画布
   2. 改变结束
      1. 获取当前显示地图中心及左上角的经纬度并计算两者差异
      2. 获取当前显示画布中心及左上角的屏幕坐标并计算两者差异
      3. 将绘画路径数组中的每条路径从经纬度形式转换为屏幕坐标形式，并绘制路径

屏幕坐标转换为经纬度坐标公式（画布左上角屏幕坐标为(0,0)）：

$$lat = topLeft.latitude + y * latDiff / screenYDiff$$

$$lng = topLeft.longitude + x * lngDiff / screenXDiff$$

经纬度坐标转换为屏幕坐标公式：

$$X = (lng - topLeft.longitude) / lngDiff * screenXDiff$$

$$Y = (lat - topLeft.latitude) / latDiff * screenYDiff$$

<a id="markdown-162-后端的api接口算法设计" name="162-后端的api接口算法设计"></a>
### 1.6.2. 后端的API接口算法设计
1. `@bp.route('/register', methods=('GET', 'POST'))`
实现用户创建账号，能根据各种情况完成用户注册的后端功能，包括前端数据结构完备性检查，以及调用后端数据库的接口函数将前端获取的数据加入到数据库中，以及向前端返回对应的操作消息。

2. `@bp.route('/login', methods=('GET', 'POST'))`
响应前端的GET请求，完成前端页面的显示，并根据前端传输的信息，在数据库中记性查询，并返回数据库中查询的结果，如果登陆出错则将出错信息弹窗到页面上，如果登陆成功，则跳转到主页面。

3. `@bp.route('/', methods=('GET', 'POST'))`
能够展示当前所有的课程以及其信息，并且能够根据对应的按钮实现对应的功能。

4. `@bp.route('/class_info2', methods=('GET', 'POST'))`
通过前端的post信息生成特定的url以供class_info函数使用。

5. `@bp.route('/<int:id>/class_info', methods=('GET', 'POST'))`
根据传入的特定课程的url返回对应渲染页面。

6. `@bp.route('/message2', methods=('GET', 'POST'))`
实现用户注销功能。

7. `@bp.route('/message1', methods=('GET', 'POST'))`
实现选课和退选功能。

8. `@bp.route('/user', methods=('GET', 'POST'))`
实现个人中心的页面，能够针对不同身份的人进行不同身份的显示。

9. `@bp.route('/setting', methods=('GET', 'POST'))`
GET请求时显示当前用户在数据库中已经填写的数据，POST请求时根据其填写的数据完成用户在数据库中数据的更新。

10. `@bp.route('/classinfo', methods=('GET', 'POST'))`
实现老师发布新课程。

11. `@bp.route('/class_discussions', methods=('GET', 'POST'))`
实现自由讨论区的功能。

12. `@bp.route('/message_x', methods=('GET', 'POST'))`
完成特定课程的url生成。

13. `@bp.route('/<int:course_id>/class_comments', methods=('GET', 'POST'))`
实现针对特定课程的评价区。

<a id="markdown-17-数据管理说明" name="17-数据管理说明"></a>
## 1.7. 数据管理说明
本项目为基于Python中的Flask框架搭建的Web选课平台，为了便于数据的存取，后台使用了 Mysql+pymysql 的数据库框架，底层使用单机的Mysql数据库进行数据的存储。
考虑到Web开发中数据关系的复杂性，故在项目中使用了对象关系映射器技术（Object Relational Mappers，ORM），即python中较有名的ORM框架，SQLAlchemy。

<a id="markdown-171-使用数据库概述" name="171-使用数据库概述"></a>
### 1.7.1. 使用数据库概述
1. Mysql
MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
2. SQLAlchemy
SQLAlchemy 在Python Web 框架中得到了广泛应用，它是一个Python的ORM框架，ORM就是把数据库表的行与相应的对象建立关联，互相转换。由于像Mysql关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。
使用 SQLAlchemy等独立 ORM 的一个优势就是它允许开发人员首先考虑数据模型，并能决定稍后可视化数据的方式。ORM作为顶层，即将表项的数据结构抽象出来，方便程序员在程序中设计数据关系，通过engine转换为底层数据库的API，进而实现对底层数据库的读写。